"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1657],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>k});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),d=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(o.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=d(a),h=i,k=m["".concat(o,".").concat(h)]||m[h]||u[h]||r;return a?n.createElement(k,l(l({ref:t},p),{},{components:a})):n.createElement(k,l({ref:t},p))}));function k(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=h;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[m]="string"==typeof e?e:i,l[1]=s;for(var d=2;d<r;d++)l[d]=a[d];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},2652:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var n=a(7462),i=(a(7294),a(3905));const r={},l="Kvrocks data structures design",s={unversionedId:"data-structure-on-rocksdb",id:"data-structure-on-rocksdb",title:"Kvrocks data structures design",description:"Kvrocks uses the RocksDB as storage, it's developed by Facebook which is built on LevelDB with many extra features, like column family, transaction and backup, see the RocksDB wiki: Features Not In LevelDB. The basic operations in RocksDB are Put(key, value), Get(key), Delete(key), other complex structures aren't supported.",source:"@site/community/data-structure-on-rocksdb.md",sourceDirName:".",slug:"/data-structure-on-rocksdb",permalink:"/community/data-structure-on-rocksdb",draft:!1,editUrl:"https://github.com/apache/kvrocks-website/tree/main/community/data-structure-on-rocksdb.md",tags:[],version:"current",frontMatter:{},sidebar:"community",previous:{title:"Internals",permalink:"/community/category/internals"},next:{title:"Releases",permalink:"/community/category/releases"}},o={},d=[{value:"User Key Encoding",id:"user-key-encoding",level:2},{value:"Encoding Version and Data Type",id:"encoding-version-and-data-type",level:2},{value:"String",id:"string",level:2},{value:"Hash",id:"hash",level:2},{value:"hash metadata",id:"hash-metadata",level:4},{value:"hash sub keys-values",id:"hash-sub-keys-values",level:4},{value:"Set",id:"set",level:2},{value:"List",id:"list",level:2},{value:"list metadata",id:"list-metadata",level:4},{value:"list sub keys-values",id:"list-sub-keys-values",level:4},{value:"ZSet",id:"zset",level:2},{value:"zset metadata",id:"zset-metadata",level:4},{value:"zset sub keys-values",id:"zset-sub-keys-values",level:4},{value:"Bitmap",id:"bitmap",level:2},{value:"bitmap metadata",id:"bitmap-metadata",level:4},{value:"bitmap sub keys-values",id:"bitmap-sub-keys-values",level:4},{value:"SortedInt",id:"sortedint",level:2},{value:"Stream",id:"stream",level:2},{value:"stream metadata",id:"stream-metadata",level:4},{value:"stream sub keys-values",id:"stream-sub-keys-values",level:4},{value:"Bloom Filter",id:"bloom-filter",level:2},{value:"Bloom Filter metadata",id:"bloom-filter-metadata",level:4},{value:"Bloom Filter sub keys-values",id:"bloom-filter-sub-keys-values",level:4},{value:"JSON",id:"json",level:2}],p={toc:d},m="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(m,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"kvrocks-data-structures-design"},"Kvrocks data structures design"),(0,i.kt)("p",null,"Kvrocks uses the RocksDB as storage, it's developed by Facebook which is built on LevelDB with many extra features, like column family, transaction and backup, see the RocksDB wiki: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/RocksDB/wiki/Features-Not-in-LevelDB"},"Features Not In LevelDB"),". The basic operations in RocksDB are ",(0,i.kt)("inlineCode",{parentName:"p"},"Put(key, value)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Get(key)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Delete(key)"),", other complex structures aren't supported."),(0,i.kt)("p",null,"The main goal of this doc is to explain how we build the Redis hash/list/set/zset/bitmap/stream on RocksDB. Most of the design were derived from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Qihoo360/blackwidow"},"Qihoo360/Blackwidow"),", but with little modification, like the bitmap design, it's a fascinating part."),(0,i.kt)("h2",{id:"user-key-encoding"},"User Key Encoding"),(0,i.kt)("p",null,"Kvrocks prefixes the user key with the ",(0,i.kt)("inlineCode",{parentName:"p"},"namespace")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"cluster slot"),". The namespace helps identify the associated namespace for each user key,\nwhile the cluster slot determines its slot when cluster mode is enabled."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"+-------------+-------------+------------------------------+-----------------+------------+-------------+-----------+\n|  ns size    |  namespace  |   cluster slot               |  user key size  |  user key  |   version   |  sub key  |\n| (1byte: X)  |   (Xbyte)   | (2byte when cluster enabled) |   (4byte: Y)    |   (YByte)  |   (8byte)   |  (ZByte)  |\n+-------------+-------------+------------------------------+-----------------+------------+-------------+-----------+\n")),(0,i.kt)("h2",{id:"encoding-version-and-data-type"},"Encoding Version and Data Type"),(0,i.kt)("p",null,"The encoding version (currently ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),") and data type is encoded in the ",(0,i.kt)("inlineCode",{parentName:"p"},"flags")," field. The data type is encoded from the least significant bit (LSB),\nwhile the encoding version is encoded from the most significant bit (MSB)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"+----------------------------------------+\n|               flags                    |\n+----------------------------------------+\n|  (1byte: | version -> <- data type |)  |\n+----------------------------------------+\n")),(0,i.kt)("p",null,"For example, the encoding version ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," and the data type String (",(0,i.kt)("inlineCode",{parentName:"p"},"1"),") is encoded as ",(0,i.kt)("inlineCode",{parentName:"p"},"0 0 0 0 | 0 0 0 1"),",\nwhile the encoding version ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," and the data type Hash (",(0,i.kt)("inlineCode",{parentName:"p"},"2"),") is encoded as ",(0,i.kt)("inlineCode",{parentName:"p"},"1 0 0 0 | 0 0 1 0"),".\nThe values encoded for other data types in flags can be found in the table below."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"data type"),(0,i.kt)("th",{parentName:"tr",align:null},"enum value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"String"),(0,i.kt)("td",{parentName:"tr",align:null},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Hash"),(0,i.kt)("td",{parentName:"tr",align:null},"2")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"List"),(0,i.kt)("td",{parentName:"tr",align:null},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Set"),(0,i.kt)("td",{parentName:"tr",align:null},"4")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZSet"),(0,i.kt)("td",{parentName:"tr",align:null},"5")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Bitmap"),(0,i.kt)("td",{parentName:"tr",align:null},"6")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SortedInt"),(0,i.kt)("td",{parentName:"tr",align:null},"7")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Stream"),(0,i.kt)("td",{parentName:"tr",align:null},"8")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"BloomFilter"),(0,i.kt)("td",{parentName:"tr",align:null},"9")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON"),(0,i.kt)("td",{parentName:"tr",align:null},"10")))),(0,i.kt)("p",null,"In the encoding version ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"expire")," is stored in seconds and as a 4byte field (32bit integer), ",(0,i.kt)("inlineCode",{parentName:"p"},"size")," is stored as also a 4byte field (32bit integer);\nwhile in the encoding version ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"expire")," is stored in milliseconds and as a 8byte field (64bit integer), ",(0,i.kt)("inlineCode",{parentName:"p"},"size")," is stored as also a 8byte field (64bit integer).\nIn the following text, we will refer to the length of ",(0,i.kt)("inlineCode",{parentName:"p"},"expire")," field as ",(0,i.kt)("inlineCode",{parentName:"p"},"Ebyte")," and the length of ",(0,i.kt)("inlineCode",{parentName:"p"},"size")," field as ",(0,i.kt)("inlineCode",{parentName:"p"},"Sbyte"),", in order to describe different encoding versions consistently."),(0,i.kt)("h2",{id:"string"},"String"),(0,i.kt)("p",null,"Redis string is key-value with expire time, so it's very easy to translate the Redis string into RocksDB key-value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+--------------------+\nkey =>  |  flags   |  expire    |       payload      |\n        | (1byte)  | (Ebyte)    |       (Nbyte)      |\n        +----------+------------+--------------------+\n")),(0,i.kt)("p",null,"We prepend 1-byte ",(0,i.kt)("inlineCode",{parentName:"p"},"flags")," and 4-bytes expire before the user's value:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"flags")," is used to tell the Kvrocks which encoding version and type of this key-value"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expire")," stores the absolute time of key should be expired, zero means the key-value would never expire"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"payload")," is the user's raw value")),(0,i.kt)("h2",{id:"hash"},"Hash"),(0,i.kt)("p",null,"Redis hashmap(dict) is like the hashmap in many programming languages, it is used to implement an associative array abstract data type, a structure that can map keys to values. The direct way to implement the hash in RocksDB is serialized the keys/values into one value and store it like the string, but the drawback is performance impact when the keys/values grew bigger. So we split the hash sub keys/values into a single key-value in RocksDB, track it with metadata."),(0,i.kt)("h4",{id:"hash-metadata"},"hash metadata"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("p",null,"The value of key we call it metadata here, it stored the metadata of hash key includes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"flags")," like the string, the field shows what type this key is"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expire")," is the same as the string type, record the expiration time"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"version")," is used to accomplish fast delete when the number of sub keys/values grew bigger"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"size")," records the number sub keys/values in this hash key")),(0,i.kt)("h4",{id:"hash-sub-keys-values"},"hash sub keys-values"),(0,i.kt)("p",null,"We use extra keys-values to store the hash keys-values, the format is like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                     +---------------+\nkey|version|field => |     value     |\n                     +---------------+\n")),(0,i.kt)("p",null,"We prepend the hash ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"version")," before the hash field, the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"version")," is from the metadata. For example, when the request ",(0,i.kt)("inlineCode",{parentName:"p"},"hget h1 f1")," is received, Kvrocks fetches the metadata by hash key(here is ",(0,i.kt)("inlineCode",{parentName:"p"},"h1"),"), then concatenate the hash key, version, field as new key, then fetches the value with the new key."),(0,i.kt)("admonition",{title:"Why store version in the metadata?",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"We store the hash keys/values into a single key-value, assume we store millions of sub keys-values in one hash key. If user delete this key, then Kvrocks must iterator millions of sub keys-values and delete them, which would cause performance problem. With version, we can quickly delete the metadata and then recycle the others keys-values in compaction background threads. The cost is those tombstone keys would take some disk storage. You can regard the version as an atomic increment number, but it's combined with a timestamp.")),(0,i.kt)("h2",{id:"set"},"Set"),(0,i.kt)("p",null,"Redis set can be regarded as a hash, with the value of sub-key always being null, the metadata is the same with the one in hash:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("p",null,"and the sub keys-values in RocksDB would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                      +---------------+\nkey|version|member => |     NULL      |\n                      +---------------+\n")),(0,i.kt)("h2",{id:"list"},"List"),(0,i.kt)("h4",{id:"list-metadata"},"list metadata"),(0,i.kt)("p",null,"Redis list is also organized by metadata and sub keys-values, and sub key is index instead of the user key. Metadata is like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |  head     |  tail     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   | (8byte)   | (8byte)   |\n        +----------+------------+-----------+-----------+-----------+-----------+\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"head")," is the starting position of the list head"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tail")," is the stopping position of the list tail")),(0,i.kt)("p",null,"The meaning of other fields are the same as other types, just add extra head/tail to record the boundary of the list."),(0,i.kt)("h4",{id:"list-sub-keys-values"},"list sub keys-values"),(0,i.kt)("p",null,"The subkey in list is composed by list key, version and index, index is calculated from metadata's head or tail. For example, when the user requests the ",(0,i.kt)("inlineCode",{parentName:"p"},"rpush list elem"),", Kvrocks would fetch the metadata with list key, then generate the subkey with list key, version and tail, simply increase the tail, then write the metadata and subkey's value back to RocksDB."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                     +---------------+\nkey|version|index => |     value     |\n                     +---------------+\n")),(0,i.kt)("h2",{id:"zset"},"ZSet"),(0,i.kt)("p",null,"Redis zset is set with sorted property, so it's a little different from other types. It must be able to search with the member, as well as to retrieve members with score range."),(0,i.kt)("h4",{id:"zset-metadata"},"zset metadata"),(0,i.kt)("p",null,"The metadata of zset is still same with set, like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("h4",{id:"zset-sub-keys-values"},"zset sub keys-values"),(0,i.kt)("p",null,"The value of sub key isn't null, we need a way to range the members with the score. So the zset has two types of sub keys-values, one for mapping the members-scores, and one for score range."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                            +---------------+\nkey|version|member       => |     score     |   (1)\n                            +---------------+\n\n                            +---------------+\nkey|version|score|member => |     NULL      |   (2)\n                            +---------------+\n")),(0,i.kt)("p",null,"If the user wants to get the score of the member or check the member exists or not, it would try the first one."),(0,i.kt)("h2",{id:"bitmap"},"Bitmap"),(0,i.kt)("p",null,"Redis bitmap is the most interesting part in Kvrocks design, unlike other types, it's not subkey and the value would be very large if the user treats it as a sparse array. It's apparent that the things would break down if we store the bitmap into a single value, so we should break the bitmap value into multiple fragments. Another behavior of bitmap is writing to arbitrary index, it's very similar to the access model of the Linux virtual memory, so the idea of the bitmap design came from that."),(0,i.kt)("h4",{id:"bitmap-metadata"},"bitmap metadata"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("h4",{id:"bitmap-sub-keys-values"},"bitmap sub keys-values"),(0,i.kt)("p",null,"We break the bitmap values into fragments(1KiB, 8192 bits/fragment), and subkey is the index of the fragment. For example, when the request to set the bit of 1024 would locate in the first fragment with index 0, to set a bit of 80970 would locate in 10th fragment with index 9."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                     +---------------+\nkey|version|index => |    fragment   |\n                     +---------------+\n")),(0,i.kt)("p",null,"When the user requests to get it of position P, Kvrocks would first fetch the metadata with bitmap's key and calculate the index of the fragment with bit position, then fetch the bitmap fragment with composed key and find the bit in fragment offset. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"getbit bitmap 8193"),", the fragment index is ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," (8193/8192) and subkey is ",(0,i.kt)("inlineCode",{parentName:"p"},"bitmap|1|1")," (when the version is 1), then fetch the subkey from RocksDB and check if the bit of offset ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"(8193%8192) is set or not."),(0,i.kt)("h2",{id:"sortedint"},"SortedInt"),(0,i.kt)("p",null,"SortedInt is a set with members being type int and sorted in ascending order:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("p",null,"And the sub keys-values in RocksDB would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                  +---------------+\nkey|version|id => |      NULL     |\n                  +---------------+\n")),(0,i.kt)("h2",{id:"stream"},"Stream"),(0,i.kt)("p",null,"Each entry in a stream has its unique ID in the form of ",(0,i.kt)("inlineCode",{parentName:"p"},"MS-SEQ")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"MS")," is the number of milliseconds and ",(0,i.kt)("inlineCode",{parentName:"p"},"SEQ")," is the counter for entries added within the same millisecond. These two values are concatenated with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," (minus sign). The entry ID may be generated by the server or explicitly set by the client. A stream metadata tracks the ID of the last added entry."),(0,i.kt)("h4",{id:"stream-metadata"},"stream metadata"),(0,i.kt)("p",null,"Redis stream is organized by the metadata and sub keys-values. The metadata has fields mentioned before (",(0,i.kt)("inlineCode",{parentName:"p"},"flags"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"expiration"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"version"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"size"),") and additional fields, that are specific only for this data type. The structure of the metadata value is the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"flags")," (1 byte)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expiration")," (Ebytes)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"version")," (8 bytes)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"size")," (Sbytes)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LGE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the last generated entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LGE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the last generated entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RFE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the very first entry ID that was added to the stream"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RFE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the very first entry ID that was added to the stream"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MDE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the max deleted entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MDE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the max deleted entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the current first entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the current first entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the current last entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the current last entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TNE")," (8 bytes) stores the total number of entries that were added to the stream during its lifetime")),(0,i.kt)("h4",{id:"stream-sub-keys-values"},"stream sub keys-values"),(0,i.kt)("p",null,"The sub-key in a stream is composed by the stream key, version and the entry ID. The entry ID is encoded as two consecutive 8-bytes integer values (",(0,i.kt)("inlineCode",{parentName:"p"},"EID MS")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"EID SEQ"),"). The stream entry value may represent any even number of strings. This value is encoded as a sequence of strings and each string value is prepended by its length as a 4-bytes variable integer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                              +-----------------------+\nkey|version|EID MS|EID SEQ => |     encoded value     |\n                              +-----------------------+\n")),(0,i.kt)("h2",{id:"bloom-filter"},"Bloom Filter"),(0,i.kt)("p",null,"Redis Bloom filter is a space-efficient probabilistic data structure used to test whether an element is a member of a set. It's implemented as ",(0,i.kt)("a",{parentName:"p",href:"https://redis.io/docs/data-types/probabilistic/bloom-filter/"},"a Redis module"),", which means it can be used to efficiently perform set membership tests."),(0,i.kt)("p",null,'The underlying structure of a Bloom filter is a bit array, which is a fixed-size array of bits, typically implemented as a contiguous block of memory and storage. We choose "split block bloom filter", as described in section 2.1 of ',(0,i.kt)("a",{parentName:"p",href:"https://www.eecs.harvard.edu/~michaelm/postscripts/im2005b.pdf"},"Network Applications of Bloom Filters: A Survey"),". In a split block bloom filter, the bit array is divided into fixed-size blocks, and each block is treated as an independent Bloom filter. This approach allows for more efficient memory usage, especially when dealing with relatively large Bloom filters. The split block bloom filter is utilized in various systems such as RocksDB, Parquet, and Impala. For further details, please refer to the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/parquet-format/blob/master/BloomFilter.md"},"BloomFilter.md")," document."),(0,i.kt)("p",null,"We also enable users to scale the Bloom filter without needing to know the specific number of elements. As the number of elements in a Bloom filter grows, the probability of false positives also increases. To address this, one approach is to utilize a layered Bloom filter, also known as a cascading Bloom filter. In a layered Bloom filter, multiple independent Bloom filters are used in a cascading fashion. When checking for membership, the element is first checked against the first (top) filter. If it is not found, it is then checked against the second filter, and so on. This approach allows for a more controlled false positive rate, as each layer can be tuned to a different false positive probability. Additionally, when a layer becomes full, a new layer can be added, allowing the Bloom filter to dynamically adapt to changes in the number of elements. This layered structure effectively maintains the efficiency and effectiveness of the Bloom filter as the number of elements grows."),(0,i.kt)("h4",{id:"bloom-filter-metadata"},"Bloom Filter metadata"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"              +---------+---------+---------+---------+-----------------------+-----------+---------------+------------+-------------+\n              | flags   | expire  | version |  size   | number of sub-filters | expansion | base_capacity | error_rate | bloom_bytes |\n key =>       +---------+---------+---------+---------+-----------------------+-----------+---------------+------------+-------------+\n              | (1byte) | (Ebyte) | (8byte) | (Sbyte) | (2byte)               | (2byte)   | (4byte)       | (8byte)    | (4byte)     |\n              +---------+---------+---------+---------+-----------------------+-----------+---------------+------------+-------------+\n")),(0,i.kt)("h4",{id:"bloom-filter-sub-keys-values"},"Bloom Filter sub keys-values"),(0,i.kt)("p",null,"We break the bitmap values into fragments(each fragment is a split block bloom filter with size ",(0,i.kt)("inlineCode",{parentName:"p"},"base_capacity * (expansion ^ index)"),"), and subkey is the index of the fragment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"             +---------------+\nkey|index => |    filter     |\n             +---------------+\n")),(0,i.kt)("h2",{id:"json"},"JSON"),(0,i.kt)("p",null,"Kvrocks supports the JSON data type just like ",(0,i.kt)("a",{parentName:"p",href:"https://redis.io/docs/data-types/json/"},"RedisJSON"),", which implements various data operations on ",(0,i.kt)("a",{parentName:"p",href:"https://ecma-international.org/publications-and-standards/standards/ecma-404/"},"ECMA-404 The JSON Data Interchange Standard"),"."),(0,i.kt)("p",null,"The current underlying encoding of JSON data type is relatively simple and similar to String:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"        +----------+------------+-----------+--------------------+\nkey =>  |  flags   |  expire    |  format   |       payload      |\n        | (1byte)  | (Ebyte)    |  (1byte)  |       (Nbyte)      |\n        +----------+------------+-----------+--------------------+\n")),(0,i.kt)("p",null,"where the ",(0,i.kt)("inlineCode",{parentName:"p"},"payload")," is a string encoded in the corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"format"),":"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"format"),(0,i.kt)("th",{parentName:"tr",align:null},"enum value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON"),(0,i.kt)("td",{parentName:"tr",align:null},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"CBOR"),(0,i.kt)("td",{parentName:"tr",align:null},"1")))),(0,i.kt)("p",null,"Also, if we decide to add a more IO-friendly format to avoid reading all payload to the memory before searching an element via JSONPath or seperate a relatively large JSON to multiple key-values, we can take advantage of the ",(0,i.kt)("inlineCode",{parentName:"p"},"format")," field."))}u.isMDXComponent=!0}}]);