"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1657],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>k});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),d=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=d(e.components);return n.createElement(o.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=d(a),h=i,k=p["".concat(o,".").concat(h)]||p[h]||u[h]||r;return a?n.createElement(k,s(s({ref:t},m),{},{components:a})):n.createElement(k,s({ref:t},m))}));function k(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=h;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[p]="string"==typeof e?e:i,s[1]=l;for(var d=2;d<r;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},2652:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var n=a(7462),i=(a(7294),a(3905));const r={},s="Data structures design",l={unversionedId:"data-structure-on-rocksdb",id:"data-structure-on-rocksdb",title:"Data structures design",description:"Apache Kvrocks\u2122 uses the RocksDB as storage, it's developed by Facebook which is built on LevelDB with many extra features, like column family, transaction and backup, see the RocksDB wiki: Features Not In LevelDB. The basic operations in RocksDB are Put(key, value), Get(key), Delete(key), other complex structures aren't supported.",source:"@site/community/data-structure-on-rocksdb.md",sourceDirName:".",slug:"/data-structure-on-rocksdb",permalink:"/community/data-structure-on-rocksdb",draft:!1,editUrl:"https://github.com/apache/kvrocks-website/tree/main/community/data-structure-on-rocksdb.md",tags:[],version:"current",frontMatter:{},sidebar:"community",previous:{title:"Internals",permalink:"/community/category/internals"},next:{title:"Releases",permalink:"/community/category/releases"}},o={},d=[{value:"User Key Encoding",id:"user-key-encoding",level:2},{value:"Encoding Version and Data Type",id:"encoding-version-and-data-type",level:2},{value:"String",id:"string",level:2},{value:"Hash",id:"hash",level:2},{value:"hash metadata",id:"hash-metadata",level:4},{value:"hash sub keys-values",id:"hash-sub-keys-values",level:4},{value:"Set",id:"set",level:2},{value:"List",id:"list",level:2},{value:"list metadata",id:"list-metadata",level:4},{value:"list sub keys-values",id:"list-sub-keys-values",level:4},{value:"ZSet",id:"zset",level:2},{value:"zset metadata",id:"zset-metadata",level:4},{value:"zset sub keys-values",id:"zset-sub-keys-values",level:4},{value:"Bitmap",id:"bitmap",level:2},{value:"bitmap metadata",id:"bitmap-metadata",level:4},{value:"bitmap sub keys-values",id:"bitmap-sub-keys-values",level:4},{value:"SortedInt",id:"sortedint",level:2},{value:"Stream",id:"stream",level:2},{value:"stream metadata",id:"stream-metadata",level:4},{value:"stream sub keys-values",id:"stream-sub-keys-values",level:4},{value:"stream consumer group metadata",id:"stream-consumer-group-metadata",level:4},{value:"stream consumer metadata",id:"stream-consumer-metadata",level:4},{value:"PEL entries",id:"pel-entries",level:4},{value:"Bloom Filter",id:"bloom-filter",level:2},{value:"Bloom Filter metadata",id:"bloom-filter-metadata",level:4},{value:"Bloom Filter sub keys-values",id:"bloom-filter-sub-keys-values",level:4},{value:"JSON",id:"json",level:2},{value:"HyperLogLog",id:"hyperloglog",level:2},{value:"HyperLogLog metadata",id:"hyperloglog-metadata",level:4},{value:"hyperloglog sub keys-values",id:"hyperloglog-sub-keys-values",level:4}],m={toc:d},p="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(p,(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"data-structures-design"},"Data structures design"),(0,i.kt)("p",null,"Apache Kvrocks\u2122 uses the RocksDB as storage, it's developed by Facebook which is built on LevelDB with many extra features, like column family, transaction and backup, see the RocksDB wiki: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebook/RocksDB/wiki/Features-Not-in-LevelDB"},"Features Not In LevelDB"),". The basic operations in RocksDB are ",(0,i.kt)("inlineCode",{parentName:"p"},"Put(key, value)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Get(key)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Delete(key)"),", other complex structures aren't supported."),(0,i.kt)("p",null,"The main goal of this doc is to explain how we build the Redis hash/list/set/zset/bitmap/stream on RocksDB. Most of the design were derived from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Qihoo360/blackwidow"},"Qihoo360/Blackwidow"),", but with little modification, like the bitmap design, it's a fascinating part."),(0,i.kt)("h2",{id:"user-key-encoding"},"User Key Encoding"),(0,i.kt)("p",null,"Kvrocks prefixes the user key with the ",(0,i.kt)("inlineCode",{parentName:"p"},"namespace")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"cluster slot"),". The namespace helps identify the associated namespace for each user key,\nwhile the cluster slot determines its slot when cluster mode is enabled."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"+-------------+-------------+------------------------------+-----------------+------------+-------------+-----------+\n|  ns size    |  namespace  |   cluster slot               |  user key size  |  user key  |   version   |  sub key  |\n| (1byte: X)  |   (Xbyte)   | (2byte when cluster enabled) |   (4byte: Y)    |   (YByte)  |   (8byte)   |  (ZByte)  |\n+-------------+-------------+------------------------------+-----------------+------------+-------------+-----------+\n")),(0,i.kt)("h2",{id:"encoding-version-and-data-type"},"Encoding Version and Data Type"),(0,i.kt)("p",null,"The encoding version (currently ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),") and data type is encoded in the ",(0,i.kt)("inlineCode",{parentName:"p"},"flags")," field. The data type is encoded from the least significant bit (LSB),\nwhile the encoding version is encoded from the most significant bit (MSB)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"+----------------------------------------+\n|               flags                    |\n+----------------------------------------+\n|  (1byte: | version -> <- data type |)  |\n+----------------------------------------+\n")),(0,i.kt)("p",null,"For example, the encoding version ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," and the data type String (",(0,i.kt)("inlineCode",{parentName:"p"},"1"),") is encoded as ",(0,i.kt)("inlineCode",{parentName:"p"},"0 0 0 0 | 0 0 0 1"),",\nwhile the encoding version ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," and the data type Hash (",(0,i.kt)("inlineCode",{parentName:"p"},"2"),") is encoded as ",(0,i.kt)("inlineCode",{parentName:"p"},"1 0 0 0 | 0 0 1 0"),".\nThe values encoded for other data types in flags can be found in the table below."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"data type"),(0,i.kt)("th",{parentName:"tr",align:null},"enum value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"String"),(0,i.kt)("td",{parentName:"tr",align:null},"1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Hash"),(0,i.kt)("td",{parentName:"tr",align:null},"2")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"List"),(0,i.kt)("td",{parentName:"tr",align:null},"3")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Set"),(0,i.kt)("td",{parentName:"tr",align:null},"4")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ZSet"),(0,i.kt)("td",{parentName:"tr",align:null},"5")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Bitmap"),(0,i.kt)("td",{parentName:"tr",align:null},"6")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"SortedInt"),(0,i.kt)("td",{parentName:"tr",align:null},"7")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Stream"),(0,i.kt)("td",{parentName:"tr",align:null},"8")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"BloomFilter"),(0,i.kt)("td",{parentName:"tr",align:null},"9")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON"),(0,i.kt)("td",{parentName:"tr",align:null},"10")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Hyperloglog"),(0,i.kt)("td",{parentName:"tr",align:null},"11")))),(0,i.kt)("p",null,"In the encoding version ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"expire")," is stored in seconds and as a 4byte field (32bit integer), ",(0,i.kt)("inlineCode",{parentName:"p"},"size")," is stored as also a 4byte field (32bit integer);\nwhile in the encoding version ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"expire")," is stored in milliseconds and as a 8byte field (64bit integer), ",(0,i.kt)("inlineCode",{parentName:"p"},"size")," is stored as also a 8byte field (64bit integer).\nIn the following text, we will refer to the length of ",(0,i.kt)("inlineCode",{parentName:"p"},"expire")," field as ",(0,i.kt)("inlineCode",{parentName:"p"},"Ebyte")," and the length of ",(0,i.kt)("inlineCode",{parentName:"p"},"size")," field as ",(0,i.kt)("inlineCode",{parentName:"p"},"Sbyte"),", in order to describe different encoding versions consistently."),(0,i.kt)("h2",{id:"string"},"String"),(0,i.kt)("p",null,"Redis string is key-value with expire time, so it's very easy to translate the Redis string into RocksDB key-value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+--------------------+\nkey =>  |  flags   |  expire    |       payload      |\n        | (1byte)  | (Ebyte)    |       (Nbyte)      |\n        +----------+------------+--------------------+\n")),(0,i.kt)("p",null,"We prepend 1-byte ",(0,i.kt)("inlineCode",{parentName:"p"},"flags")," and 4-bytes expire before the user's value:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"flags")," is used to tell the Kvrocks which encoding version and type of this key-value"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expire")," stores the absolute time of key should be expired, zero means the key-value would never expire"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"payload")," is the user's raw value")),(0,i.kt)("h2",{id:"hash"},"Hash"),(0,i.kt)("p",null,"Redis hashmap(dict) is like the hashmap in many programming languages, it is used to implement an associative array abstract data type, a structure that can map keys to values. The direct way to implement the hash in RocksDB is serialized the keys/values into one value and store it like the string, but the drawback is performance impact when the keys/values grew bigger. So we split the hash sub keys/values into a single key-value in RocksDB, track it with metadata."),(0,i.kt)("h4",{id:"hash-metadata"},"hash metadata"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("p",null,"The value of key we call it metadata here, it stored the metadata of hash key includes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"flags")," like the string, the field shows what type this key is"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expire")," is the same as the string type, record the expiration time"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"version")," is used to accomplish fast delete when the number of sub keys/values grew bigger"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"size")," records the number sub keys/values in this hash key")),(0,i.kt)("h4",{id:"hash-sub-keys-values"},"hash sub keys-values"),(0,i.kt)("p",null,"We use extra keys-values to store the hash keys-values, the format is like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                     +---------------+\nkey|version|field => |     value     |\n                     +---------------+\n")),(0,i.kt)("p",null,"We prepend the hash ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"version")," before the hash field, the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"version")," is from the metadata. For example, when the request ",(0,i.kt)("inlineCode",{parentName:"p"},"hget h1 f1")," is received, Kvrocks fetches the metadata by hash key(here is ",(0,i.kt)("inlineCode",{parentName:"p"},"h1"),"), then concatenate the hash key, version, field as new key, then fetches the value with the new key."),(0,i.kt)("admonition",{title:"Why store version in the metadata?",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"We store the hash keys/values into a single key-value, assume we store millions of sub keys-values in one hash key. If user delete this key, then Kvrocks must iterator millions of sub keys-values and delete them, which would cause performance problem. With version, we can quickly delete the metadata and then recycle the others keys-values in compaction background threads. The cost is those tombstone keys would take some disk storage. You can regard the version as an atomic increment number, but it's combined with a timestamp.")),(0,i.kt)("h2",{id:"set"},"Set"),(0,i.kt)("p",null,"Redis set can be regarded as a hash, with the value of sub-key always being null, the metadata is the same with the one in hash:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("p",null,"and the sub keys-values in RocksDB would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                      +---------------+\nkey|version|member => |     NULL      |\n                      +---------------+\n")),(0,i.kt)("h2",{id:"list"},"List"),(0,i.kt)("h4",{id:"list-metadata"},"list metadata"),(0,i.kt)("p",null,"Redis list is also organized by metadata and sub keys-values, and sub key is index instead of the user key. Metadata is like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |  head     |  tail     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   | (8byte)   | (8byte)   |\n        +----------+------------+-----------+-----------+-----------+-----------+\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"head")," is the starting position of the list head"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"tail")," is the stopping position of the list tail")),(0,i.kt)("p",null,"The meaning of other fields are the same as other types, just add extra head/tail to record the boundary of the list."),(0,i.kt)("h4",{id:"list-sub-keys-values"},"list sub keys-values"),(0,i.kt)("p",null,"The subkey in list is composed by list key, version and index, index is calculated from metadata's head or tail. For example, when the user requests the ",(0,i.kt)("inlineCode",{parentName:"p"},"rpush list elem"),", Kvrocks would fetch the metadata with list key, then generate the subkey with list key, version and tail, simply increase the tail, then write the metadata and subkey's value back to RocksDB."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                     +---------------+\nkey|version|index => |     value     |\n                     +---------------+\n")),(0,i.kt)("h2",{id:"zset"},"ZSet"),(0,i.kt)("p",null,"Redis zset is set with sorted property, so it's a little different from other types. It must be able to search with the member, as well as to retrieve members with score range."),(0,i.kt)("h4",{id:"zset-metadata"},"zset metadata"),(0,i.kt)("p",null,"The metadata of zset is still same with set, like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("h4",{id:"zset-sub-keys-values"},"zset sub keys-values"),(0,i.kt)("p",null,"The value of sub key isn't null, we need a way to range the members with the score. So the zset has two types of sub keys-values, one for mapping the members-scores, and one for score range."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                            +---------------+\nkey|version|member       => |     score     |   (1)\n                            +---------------+\n\n                            +---------------+\nkey|version|score|member => |     NULL      |   (2)\n                            +---------------+\n")),(0,i.kt)("p",null,"If the user wants to get the score of the member or check the member exists or not, it would try the first one."),(0,i.kt)("h2",{id:"bitmap"},"Bitmap"),(0,i.kt)("p",null,"Redis bitmap is the most interesting part in Kvrocks design, unlike other types, it's not subkey and the value would be very large if the user treats it as a sparse array. It's apparent that the things would break down if we store the bitmap into a single value, so we should break the bitmap value into multiple fragments. Another behavior of bitmap is writing to arbitrary index, it's very similar to the access model of the Linux virtual memory, so the idea of the bitmap design came from that."),(0,i.kt)("h4",{id:"bitmap-metadata"},"bitmap metadata"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("h4",{id:"bitmap-sub-keys-values"},"bitmap sub keys-values"),(0,i.kt)("p",null,"We break the bitmap values into fragments(1KiB, 8192 bits/fragment), and subkey is the index of the fragment. For example, when the request to set the bit of 1024 would locate in the first fragment with index 0, to set a bit of 80970 would locate in 10th fragment with index 9."),(0,i.kt)("p",null,'We use least-significant bit (LSB) numbering (also known as bit-endianness). This means that within a group of 8 bits, we read right-to-left. This is different from applying "bit" commands to string.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                     +---------------+\nkey|version|index => |    fragment   |\n                     +---------------+\n")),(0,i.kt)("p",null,"When the user requests to get it of position P, Kvrocks would first fetch the metadata with bitmap's key and calculate the index of the fragment with bit position, then fetch the bitmap fragment with composed key and find the bit in fragment offset. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"getbit bitmap 8193"),", the fragment index is ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," (8193/8192) and subkey is ",(0,i.kt)("inlineCode",{parentName:"p"},"bitmap|1|1024")," (when the version is 1, and fragment index is ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", kvrocks will use ",(0,i.kt)("inlineCode",{parentName:"p"},"1 * 1024")," as the index key), then fetch the subkey from RocksDB and check if the bit of offset ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"(8193%8192) is set or not."),(0,i.kt)("p",null,'A nonexistent segment means all bits are 0 in this segment. The bitmap design is very efficient when the bitmap is sparse. Besides, a segment could be less than 1KiB, and the "padding" bits are always regarded as 0.'),(0,i.kt)("h2",{id:"sortedint"},"SortedInt"),(0,i.kt)("p",null,"SortedInt is a set with members being type int and sorted in ascending order:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+-----------+\nkey =>  |  flags   |  expire    |  version  |  size     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (Sbyte)   |\n        +----------+------------+-----------+-----------+\n")),(0,i.kt)("p",null,"And the sub keys-values in RocksDB would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                  +---------------+\nkey|version|id => |      NULL     |\n                  +---------------+\n")),(0,i.kt)("h2",{id:"stream"},"Stream"),(0,i.kt)("p",null,"Each entry in a stream has its unique ID in the form of ",(0,i.kt)("inlineCode",{parentName:"p"},"MS-SEQ")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"MS")," is the number of milliseconds and ",(0,i.kt)("inlineCode",{parentName:"p"},"SEQ")," is the counter for entries added within the same millisecond. These two values are concatenated with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," (minus sign). The entry ID may be generated by the server or explicitly set by the client. A stream metadata tracks the ID of the last added entry."),(0,i.kt)("h4",{id:"stream-metadata"},"stream metadata"),(0,i.kt)("p",null,"Redis stream is organized by the metadata and sub keys-values. The metadata has fields mentioned before (",(0,i.kt)("inlineCode",{parentName:"p"},"flags"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"expiration"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"version"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"size"),") and additional fields, that are specific only for this data type. The structure of the metadata value is the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"flags")," (1 byte)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expiration")," (Ebytes)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"version")," (8 bytes)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"size")," (Sbytes)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LGE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the last generated entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LGE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the last generated entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RFE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the very first entry ID that was added to the stream"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"RFE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the very first entry ID that was added to the stream"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MDE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the max deleted entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MDE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the max deleted entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the current first entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the current first entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LE ID MS")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"MS")," value of the current last entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LE ID SEQ")," (8 bytes) stores the ",(0,i.kt)("inlineCode",{parentName:"li"},"SEQ")," value of the current last entry ID"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TNE")," (8 bytes) stores the total number of entries that were added to the stream during its lifetime")),(0,i.kt)("h4",{id:"stream-sub-keys-values"},"stream sub keys-values"),(0,i.kt)("p",null,"The sub-key in a stream is composed by the stream key, version and the entry ID. The entry ID is encoded as two consecutive 8-bytes integer values (",(0,i.kt)("inlineCode",{parentName:"p"},"EID MS")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"EID SEQ"),"). The stream entry value may represent any even number of strings. This value is encoded as a sequence of strings and each string value is prepended by its length as a 4-bytes variable integer."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                              +-----------------------+\nkey|version|EID MS|EID SEQ => |     encoded value     |\n                              +-----------------------+\n")),(0,i.kt)("h4",{id:"stream-consumer-group-metadata"},"stream consumer group metadata"),(0,i.kt)("p",null,"The consumer group metadata contains the basic information of the consumer group used in the ",(0,i.kt)("inlineCode",{parentName:"p"},"XINFO GROUPS")," command.\nThe key starts with the stream name, version, UINT64_MAX as a delimiter, GROUP_META which is hardcoded with 1 and consumer group name.\nThe composition of value is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"number of consumers in the group"),(0,i.kt)("li",{parentName:"ul"},"the length of the group's PEL (pending entries list)"),(0,i.kt)("li",{parentName:"ul"},"the ID of the last entry delivered to the group's consumers"),(0,i.kt)("li",{parentName:"ul"},"the ID of the last entry delivered to the group's consumers"),(0,i.kt)("li",{parentName:"ul"},"the number of entries in the stream that are still waiting to be delivered to the group's consumers.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                                                +-----------------+----------------+-------------------+--------------+-------+\nkey|version|UINT64_MAX|GROUP_META|group_name => | consumer number | pending number | last delivered id | entries read |  lag  |\n                                                |     (8byte)     |     (8byte)    |      (8byte)      |    (8byte)   |(8byte)|\n                                                +-----------------+----------------+-------------------+--------------+-------+\n")),(0,i.kt)("h4",{id:"stream-consumer-metadata"},"stream consumer metadata"),(0,i.kt)("p",null,"A consumer group contains several consumers and each consumer also has its own metadata which is used in the ",(0,i.kt)("inlineCode",{parentName:"p"},"XINFO CONSUMERS")," command.\nThe key starts with the stream key, version, UINT64_MAX as a delimiter, CONSUMER_META which is hardcoded with 2, consumer group name, consumer name.\nThe composition of value is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the number of entries in the PEL"),(0,i.kt)("li",{parentName:"ul"},"the timestamp of the last consumer interaction"),(0,i.kt)("li",{parentName:"ul"},"the timestamp of the last successful consumer interaction (actually read or claimed some entries).")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                                                                 +----------------+-----------------------+----------------------------------+\nkey|version|UINT64_MAX|CONSUMER_META|group_name|consumer_name => | pending number | last interaction time | last successful interaction time |\n                                                                 |     (8byte)    |        (8byte)        |            (8byte)               |\n                                                                 +----------------+-----------------------+----------------------------------+\n")),(0,i.kt)("h4",{id:"pel-entries"},"PEL entries"),(0,i.kt)("p",null,"A PEL entry is created after ",(0,i.kt)("inlineCode",{parentName:"p"},"XREADGROUP")," command and each entry contains some metadata. The key is composed by the stream key, version, UINT64_MAX as a delimiter, PEL_ENTRY which is hardcoded with 3, group name and the entry ID. The value is composed by last delivery time, last delivery count and consumer name. The consumer name indicates the owner of the entry and can be quickly changed by XCLAIM command."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                                                              +--------------------+---------------------+---------------+\nkey|version|UINT64_MAX|PEL_ENTRY|group_name|EID MS|EID SEQ => | last delivery time | last delivery count | consumer name |\n                                                              |       (8byte)      |       (8byte)       |    (Nbyte)    |\n                                                              +--------------------+---------------------+---------------+\n")),(0,i.kt)("h2",{id:"bloom-filter"},"Bloom Filter"),(0,i.kt)("p",null,"Redis Bloom filter is a space-efficient probabilistic data structure used to test whether an element is a member of a set. It's implemented as ",(0,i.kt)("a",{parentName:"p",href:"https://redis.io/docs/data-types/probabilistic/bloom-filter/"},"a Redis module"),", which means it can be used to efficiently perform set membership tests."),(0,i.kt)("p",null,'The underlying structure of a Bloom filter is a bit array, which is a fixed-size array of bits, typically implemented as a contiguous block of memory and storage. We choose "split block bloom filter", as described in section 2.1 of ',(0,i.kt)("a",{parentName:"p",href:"https://www.eecs.harvard.edu/~michaelm/postscripts/im2005b.pdf"},"Network Applications of Bloom Filters: A Survey"),". In a split block bloom filter, the bit array is divided into fixed-size blocks, and each block is treated as an independent Bloom filter. This approach allows for more efficient memory usage, especially when dealing with relatively large Bloom filters. The split block bloom filter is utilized in various systems such as RocksDB, Parquet, and Impala. For further details, please refer to the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/parquet-format/blob/master/BloomFilter.md"},"BloomFilter.md")," document."),(0,i.kt)("p",null,"We also enable users to scale the Bloom filter without needing to know the specific number of elements. As the number of elements in a Bloom filter grows, the probability of false positives also increases. To address this, one approach is to utilize a layered Bloom filter, also known as a cascading Bloom filter. In a layered Bloom filter, multiple independent Bloom filters are used in a cascading fashion. When checking for membership, the element is first checked against the first (top) filter. If it is not found, it is then checked against the second filter, and so on. This approach allows for a more controlled false positive rate, as each layer can be tuned to a different false positive probability. Additionally, when a layer becomes full, a new layer can be added, allowing the Bloom filter to dynamically adapt to changes in the number of elements. This layered structure effectively maintains the efficiency and effectiveness of the Bloom filter as the number of elements grows."),(0,i.kt)("h4",{id:"bloom-filter-metadata"},"Bloom Filter metadata"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"              +---------+---------+---------+---------+-----------------------+-----------+---------------+------------+-------------+\n              | flags   | expire  | version |  size   | number of sub-filters | expansion | base_capacity | error_rate | bloom_bytes |\n key =>       +---------+---------+---------+---------+-----------------------+-----------+---------------+------------+-------------+\n              | (1byte) | (Ebyte) | (8byte) | (Sbyte) | (2byte)               | (2byte)   | (4byte)       | (8byte)    | (4byte)     |\n              +---------+---------+---------+---------+-----------------------+-----------+---------------+------------+-------------+\n")),(0,i.kt)("h4",{id:"bloom-filter-sub-keys-values"},"Bloom Filter sub keys-values"),(0,i.kt)("p",null,"We break the bitmap values into fragments(each fragment is a split block bloom filter with size ",(0,i.kt)("inlineCode",{parentName:"p"},"base_capacity * (expansion ^ index)"),"), and subkey is the index of the fragment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"             +---------------+\nkey|index => |    filter     |\n             +---------------+\n")),(0,i.kt)("h2",{id:"json"},"JSON"),(0,i.kt)("p",null,"Kvrocks supports the JSON data type just like ",(0,i.kt)("a",{parentName:"p",href:"https://redis.io/docs/data-types/json/"},"RedisJSON"),", which implements various data operations on ",(0,i.kt)("a",{parentName:"p",href:"https://ecma-international.org/publications-and-standards/standards/ecma-404/"},"ECMA-404 The JSON Data Interchange Standard"),"."),(0,i.kt)("p",null,"The current underlying encoding of JSON data type is relatively simple and similar to String:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"        +----------+------------+-----------+--------------------+\nkey =>  |  flags   |  expire    |  format   |       payload      |\n        | (1byte)  | (Ebyte)    |  (1byte)  |       (Nbyte)      |\n        +----------+------------+-----------+--------------------+\n")),(0,i.kt)("p",null,"where the ",(0,i.kt)("inlineCode",{parentName:"p"},"payload")," is a string encoded in the corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"format"),":"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"format"),(0,i.kt)("th",{parentName:"tr",align:null},"enum value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"JSON"),(0,i.kt)("td",{parentName:"tr",align:null},"0")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"CBOR"),(0,i.kt)("td",{parentName:"tr",align:null},"1")))),(0,i.kt)("p",null,"Also, if we decide to add a more IO-friendly format to avoid reading all payload to the memory before searching an element via JSONPath or seperate a relatively large JSON to multiple key-values, we can take advantage of the ",(0,i.kt)("inlineCode",{parentName:"p"},"format")," field."),(0,i.kt)("h2",{id:"hyperloglog"},"HyperLogLog"),(0,i.kt)("p",null,"Redis HyperLogLog is a probabilistic data structure that estimates the cardinality of a set. The idea comes from ",(0,i.kt)("a",{parentName:"p",href:"http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf"},"original paper")," and ",(0,i.kt)("a",{parentName:"p",href:"http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf"},"paper from Google"),".  It is particularly useful for applications that require the estimation of unique elements in massive datasets, such as network traffic analysis, data warehousing, and large-scale databases."),(0,i.kt)("p",null,"The principle behind HyperLogLog is based on the idea that the number of leading zeros in the binary representation of a hash value can be used to infer the size of the set. It includes:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Hashing: Each element in the dataset is passed through a hash function, which produces a fixed-size binary string."),(0,i.kt)("li",{parentName:"ol"},"Register Array: The algorithm maintains an array of registers, each corresponding to a subset of the hash space. The size of the array is 2^p, where p is a precision parameter that determines the trade-off between accuracy and memory usage.  The HyperLogLog algorithm uses a subset of the hash value to determine the index in the register array. Specifically, it takes the first p bits of the hash value.")),(0,i.kt)("p",null,"For the remaining bits of the hash value (after the first p bits), the algorithm counts the number of leading zeros. Each entry in the array keeps track of the maximum observed for all elements that hash to the same index. If the newly encountered value is greater than the current value in the register, it updates the register with this new value."),(0,i.kt)("p",null,"Redis HyperLogLog can be thought of as a static array with a length of 16384. The array elements are called registers, which are used to store the maximum count of consecutive 0s. This register array is the input parameter for the HyperLogLog algorithm. The Redis HyperLogLog implementation uses up to 12 KB and provides a standard error of 0.81%."),(0,i.kt)("p",null,"In Kvrocks, the hyperloglog data structure is stored in following two parts:"),(0,i.kt)("h4",{id:"hyperloglog-metadata"},"HyperLogLog metadata"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"        +----------+------------+-----------+--------------+\nkey =>  |  flags   |  expire    |  version  |  HLLType     |\n        | (1byte)  | (Ebyte)    |  (8byte)  | (1byte)      |\n        +----------+------------+-----------+--------------+\n")),(0,i.kt)("p",null,'HLLType = 0 means a "dense" representation with Redis-like modified MurmurHash2 and 16384 registers with 6bit LSB numbers,\nthe values is stored like Bitmap but has smaller segment(768 bytes per segment).'),(0,i.kt)("h4",{id:"hyperloglog-sub-keys-values"},"hyperloglog sub keys-values"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"                     +---------------+\nkey|version|index => |    fragment   |\n                     +---------------+\n")),(0,i.kt)("p",null,"The register index is calculated using the first 14 bits of the user element's hash value (64 bits), which is why the register array length is 16384.\nThe length of consecutive zeros is calculated using the last 50 digits of the hash value of the user key."),(0,i.kt)("p",null,"Inspired by the bitmap implementation, HyperLogLog divides the register array into 16 segments, each with 1024 registers."))}u.isMDXComponent=!0}}]);