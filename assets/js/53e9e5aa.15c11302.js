"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6225],{5680:(e,t,n)=>{n.d(t,{xA:()=>s,yg:()=>m});var a=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),y=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=y(e.components);return a.createElement(o.Provider,{value:t},e.children)},g="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),g=y(n),c=r,m=g["".concat(o,".").concat(c)]||g[c]||p[c]||i;return n?a.createElement(m,l(l({ref:t},s),{},{components:n})):a.createElement(m,l({ref:t},s))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=c;var d={};for(var o in t)hasOwnProperty.call(t,o)&&(d[o]=t[o]);d.originalType=e,d[g]="string"==typeof e?e:r,l[1]=d;for(var y=2;y<i;y++)l[y]=n[y];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9167:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>d,toc:()=>y});var a=n(8168),r=(n(6540),n(5680));const i={},l="Index encoding format for Kvrocks Search",d={unversionedId:"kvrocks-search-index-encoding",id:"kvrocks-search-index-encoding",title:"Index encoding format for Kvrocks Search",description:"Different from the encoding method of other data structures in Kvrocks (e.g. String, Hash, ZSet ...),",source:"@site/community/kvrocks-search-index-encoding.md",sourceDirName:".",slug:"/kvrocks-search-index-encoding",permalink:"/community/kvrocks-search-index-encoding",draft:!1,editUrl:"https://github.com/apache/kvrocks-website/tree/main/community/kvrocks-search-index-encoding.md",tags:[],version:"current",frontMatter:{},sidebar:"community",previous:{title:"Data structures design",permalink:"/community/data-structure-on-rocksdb"},next:{title:"Releases",permalink:"/community/category/releases"}},o={},y=[{value:"Common encoding",id:"common-encoding",level:2},{value:"Key types",id:"key-types",level:3},{value:"Field types and flags",id:"field-types-and-flags",level:3},{value:"Metadata encoding",id:"metadata-encoding",level:2},{value:"Index metadata",id:"index-metadata",level:3},{value:"Index prefixes",id:"index-prefixes",level:3},{value:"Tag field metadata",id:"tag-field-metadata",level:3},{value:"Numeric field metadata",id:"numeric-field-metadata",level:3},{value:"HNSW Vector Field Metadata",id:"hnsw-vector-field-metadata",level:3},{value:"Required attributes",id:"required-attributes",level:4},{value:"Optional attributes",id:"optional-attributes",level:4},{value:"Index data encoding",id:"index-data-encoding",level:2},{value:"Tag field",id:"tag-field",level:3},{value:"Numeric field",id:"numeric-field",level:3},{value:"HNSW Vector field",id:"hnsw-vector-field",level:3},{value:"HNSW graph entry types",id:"hnsw-graph-entry-types",level:4},{value:"HNSW node index encoding",id:"hnsw-node-index-encoding",level:4},{value:"HNSW edge index encoding",id:"hnsw-edge-index-encoding",level:4}],s={toc:y},g="wrapper";function p(e){let{components:t,...n}=e;return(0,r.yg)(g,(0,a.A)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"index-encoding-format-for-kvrocks-search"},"Index encoding format for Kvrocks Search"),(0,r.yg)("p",null,"Different from ",(0,r.yg)("a",{parentName:"p",href:"https://kvrocks.apache.org/community/data-structure-on-rocksdb"},"the encoding method of other data structures")," in Kvrocks (e.g. String, Hash, ZSet ...),\nApache Kvrocks\u2122 Search (a.k.a. Kvrocks Search) uses an independent column family (named ",(0,r.yg)("inlineCode",{parentName:"p"},"search"),")\nand a separately designed encoding format to store indexing-related metadata and data."),(0,r.yg)("p",null,"Kvrocks Search is released since 2.11.0, see ",(0,r.yg)("a",{parentName:"p",href:"https://kvrocks.apache.org/docs/kvrocks-search"},"its docs"),"."),(0,r.yg)("h2",{id:"common-encoding"},"Common encoding"),(0,r.yg)("h3",{id:"key-types"},"Key types"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"key type"),(0,r.yg)("th",{parentName:"tr",align:null},"enum value"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"INDEX_META"),(0,r.yg)("td",{parentName:"tr",align:null},"0")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"PREFIXES"),(0,r.yg)("td",{parentName:"tr",align:null},"1")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"FIELD_META"),(0,r.yg)("td",{parentName:"tr",align:null},"2")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"FIELD"),(0,r.yg)("td",{parentName:"tr",align:null},"3")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"FIELD_ALIAS"),(0,r.yg)("td",{parentName:"tr",align:null},"4")))),(0,r.yg)("p",null,"The common encoding format of key is as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"+-------------+-------------+-------------+----------------+-------------+-------------------+\n|  ns size    |  namespace  |  key type   |  idx name size |  index name |  other fields...  |\n| (1byte: X)  |   (Xbyte)   |  (1byte)    |   (4bytes: Y)  |  (Y bytes)  |   (variable)      |\n+-------------+-------------+-------------+----------------+-------------+-------------------+\n")),(0,r.yg)("h3",{id:"field-types-and-flags"},"Field types and flags"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"field type"),(0,r.yg)("th",{parentName:"tr",align:null},"enum value"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"tag"),(0,r.yg)("td",{parentName:"tr",align:null},"1")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"numeric"),(0,r.yg)("td",{parentName:"tr",align:null},"2")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"vector"),(0,r.yg)("td",{parentName:"tr",align:null},"3")))),(0,r.yg)("p",null,"The common encoding format of a ",(0,r.yg)("em",{parentName:"p"},"field flag")," is:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"|              8 bit                                 |\n|----------------------------------------------------|\n|  noindex: 1bit | field type: 4bit | reserved: 3bit |\n")),(0,r.yg)("h2",{id:"metadata-encoding"},"Metadata encoding"),(0,r.yg)("p",null,"In Kvrocks Search, metadata refers to the metadata of an index (also known as a schema),\nincluding some properties of the index, which fields are included in this index,\nwhat type each field is, and what properties they have."),(0,r.yg)("h3",{id:"index-metadata"},"Index metadata"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"| namespace | INDEX_META | index name |      | index flag | on data type  |\n|-----------|------------|------------|  ->  |------------|---------------|\n| 1+X bytes |  1 byte    | 4+Y bytes  |  ->  |   1 byte   |    1 byte     |\n")),(0,r.yg)("p",null,"where ",(0,r.yg)("em",{parentName:"p"},"index flag")," is currently 8-bit all reserved (equals to ",(0,r.yg)("inlineCode",{parentName:"p"},"0"),"), and ",(0,r.yg)("em",{parentName:"p"},"on data type")," is one of:"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"on data type"),(0,r.yg)("th",{parentName:"tr",align:null},"enum value"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"HASH"),(0,r.yg)("td",{parentName:"tr",align:null},"2")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"JSON"),(0,r.yg)("td",{parentName:"tr",align:null},"10")))),(0,r.yg)("h3",{id:"index-prefixes"},"Index prefixes"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"| namespace | PREFIXES   | index name |      | prefix strings... |\n|-----------|------------|------------|  ->  |-------------------|\n| 1+X bytes |  1 byte    | 4+Y bytes  |  ->  |  (4+Zi)*N bytes   |\n")),(0,r.yg)("p",null,"Index prefixes are used to determine which keys belong to the tracking scope of this index.\nIt consists of an array of strings, where each string is a key prefix."),(0,r.yg)("h3",{id:"tag-field-metadata"},"Tag field metadata"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"| namespace | FIELD_META | index name | field name |      | field flag | separator  | case sensitive |\n|-----------|------------|------------|------------|  ->  |------------|------------|----------------|\n| 1+X bytes |  1 byte    | 4+Y bytes  | 4+Z bytes  |  ->  |   1 byte   |  1 byte    |     1 byte     |\n")),(0,r.yg)("p",null,"where ",(0,r.yg)("em",{parentName:"p"},"separator")," currently can only be an ASCII character, and case sensitive can be ",(0,r.yg)("inlineCode",{parentName:"p"},"0")," (false) or ",(0,r.yg)("inlineCode",{parentName:"p"},"1")," (true)."),(0,r.yg)("h3",{id:"numeric-field-metadata"},"Numeric field metadata"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"| namespace | FIELD_META | index name | field name |      | field flag |\n|-----------|------------|------------|------------|  ->  |------------|\n| 1+X bytes |  1 byte    | 4+Y bytes  | 4+Z bytes  |  ->  |   1 byte   |\n")),(0,r.yg)("h3",{id:"hnsw-vector-field-metadata"},"HNSW Vector Field Metadata"),(0,r.yg)("p",null,"This metadata format is specifically designed to support efficient vector search using the HNSW (Hierarchical Navigable Small World) algorithm. The encoding captures various parameters and settings relevant for managing the vector index properties and optimizing vector search operations."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"| namespace | FIELD_META | index name | field name |      | field flag | vector type | dimension | distance metric | initial cap |     m     | ef construction | ef runtime | epsilon | number of levels |\n|-----------|------------|------------|------------|  ->  |------------|-------------|-----------|-----------------|-------------|-----------|-----------------|------------|---------|------------------|\n| 1+X bytes |  1 byte    | 4+Y bytes  | 4+Z bytes  |  ->  |   1 byte   |   1 byte    |  2 bytes  |     1 byte      |   4 bytes   |  2 bytes  |     4 bytes     |  4 bytes   | 8 bytes |     2 bytes      |\n")),(0,r.yg)("h4",{id:"required-attributes"},"Required attributes"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"vector type"),": Specifies the type of vectors stored (e.g., ",(0,r.yg)("inlineCode",{parentName:"li"},"FLOAT32"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"FLOAT64"),"); Now Kvrocks only supports ",(0,r.yg)("inlineCode",{parentName:"li"},"FLOAT64"),". "),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"dimension"),": The dimensionality of the vectors (number of elements in each vector)."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"distance metric"),": Metric used for distance calculation between vectors (i.e. ",(0,r.yg)("inlineCode",{parentName:"li"},"L2"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"IP"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"COSINE"),").")),(0,r.yg)("h4",{id:"optional-attributes"},"Optional attributes"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"initial cap"),": Initial capacity of the HNSW graph, indicating the initial number of elements; Default is 500000. "),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"m"),": Maximum number of edges per node in the HNSW graph; Default is 16. "),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"ef construction"),": Size of the dynamic candidate list during the index construction phase; Default is 200. "),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"ef runtime"),": Size of the dynamic candidate list during the search phase; Default is 10. "),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"epsilon"),": Epsilon value for approximate search, controlling the trade-off between search precision and speed; Default is 0.01. "),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"number of levels"),": Number of levels in the HNSW graph, affecting the hierarchical structure of the graph.")),(0,r.yg)("h2",{id:"index-data-encoding"},"Index data encoding"),(0,r.yg)("p",null,"Index data refers to the information stored after indexing the real data,\nwhich is used to quickly get corresponding data in subsequent query processes."),(0,r.yg)("h3",{id:"tag-field"},"Tag field"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"| namespace | FIELD   | index name | field name | tag value  | user key   |      |    null    |\n|-----------|---------|------------|------------|------------|------------|  ->  |------------|\n| 1+X bytes | 1 byte  | 4+Y bytes  | 4+Z bytes  | 4+A bytes  | 4+B bytes  |  ->  |   0 byte   |\n")),(0,r.yg)("h3",{id:"numeric-field"},"Numeric field"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"| namespace | FIELD   | index name | field name | floating number | user key   |      |    null    |\n|-----------|---------|------------|------------|-----------------|------------|  ->  |------------|\n| 1+X bytes | 1 byte  | 4+Y bytes  | 4+Z bytes  |    8 bytes      | 4+B bytes  |  ->  |   0 byte   |\n")),(0,r.yg)("h3",{id:"hnsw-vector-field"},"HNSW Vector field"),(0,r.yg)("h4",{id:"hnsw-graph-entry-types"},"HNSW graph entry types"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"hnsw type"),(0,r.yg)("th",{parentName:"tr",align:null},"enum value"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"NODE"),(0,r.yg)("td",{parentName:"tr",align:null},"1")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"EDGE"),(0,r.yg)("td",{parentName:"tr",align:null},"2")))),(0,r.yg)("h4",{id:"hnsw-node-index-encoding"},"HNSW node index encoding"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"| namespace | FIELD   | index name | field name |   level   |    hnsw type   | user key   |      | num of neighbours | vector dimension |      vector data      |\n|-----------|---------|------------|------------|-----------|----------------|------------|  ->  |-------------------|------------------|-----------------------|\n| 1+X bytes | 1 byte  | 4+Y bytes  | 4+Z bytes  |  2 bytes  |  NODE (1 byte) | 4+B bytes  |  ->  |       2 bytes     |      2 bytes     |  dimension * 8 bytes  |\n")),(0,r.yg)("h4",{id:"hnsw-edge-index-encoding"},"HNSW edge index encoding"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"| namespace | FIELD   | index name | field name |   level   |    hnsw type   | user key 1 | user key 2 |      |    null    |\n|-----------|---------|------------|------------|-----------|----------------|------------|------------|  ->  |------------|\n| 1+X bytes | 1 byte  | 4+Y bytes  | 4+Z bytes  |  2 bytes  |  EDGE (1 byte) | 4+B bytes  | 4+B bytes  |  ->  |   0 byte   |\n")),(0,r.yg)("p",null,"where ",(0,r.yg)("em",{parentName:"p"},"user key 1")," and ",(0,r.yg)("em",{parentName:"p"},"user key 2")," represent the endpoints of an edge at a specific level within the HNSW graph."))}p.isMDXComponent=!0}}]);